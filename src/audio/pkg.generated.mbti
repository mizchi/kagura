// Generated using `moon info`, DON'T EDIT IT
package "mizchi/kagura/audio"

// Values
pub fn audio_buffer_to_clip(@mizchi/audio.AudioBuffer, Bool) -> AudioClip

pub fn audio_close() -> Unit

pub fn audio_output_latency() -> Double

pub fn audio_render_and_write(MixerAudioContext, Int) -> Int

pub fn audio_resume() -> Unit

pub fn audio_suspend() -> Unit

pub fn audio_try_initialize(AudioFormat) -> Bool

pub fn audio_write_frames(FixedArray[Float], Int) -> Int

pub fn bytes_per_sample(AudioFormat) -> Int

pub fn bytes_to_samples(AudioFormat, Int) -> Int

pub fn cd_quality_format() -> AudioFormat

pub fn clip_duration(AudioClip) -> Double

pub fn clip_sample_count(AudioClip) -> Int

pub fn clip_to_audio_buffer(AudioClip) -> @mizchi/audio.AudioBuffer

pub fn decode_audio_clip_auto(Bytes, Bool) -> AudioClip? raise @mizchi/audio.AudioError

pub fn decode_ogg_clip(Bytes, Bool) -> AudioClip raise @mizchi/audio.AudioError

pub fn decode_wav_clip(Bytes, Bool) -> AudioClip raise @mizchi/audio.AudioError

pub fn default_audio_format() -> AudioFormat

pub fn default_audio_output_stats() -> AudioOutputStats

pub fn detect_audio_format(Bytes) -> String

pub fn duration_to_samples(AudioFormat, Double) -> Int

pub fn mono_format(Int) -> AudioFormat

pub fn new_audio_clip(AudioFormat, Bytes, Bool) -> AudioClip

pub fn new_audio_output_hooks((AudioFormat) -> Bool, (FixedArray[Float], Int) -> Int, () -> Unit, () -> Unit, () -> Unit) -> AudioOutputHooks

pub fn new_audio_output_hooks_full((AudioFormat) -> Bool, (FixedArray[Float], Int) -> Int, () -> Unit, () -> Unit, () -> Unit, () -> Double) -> AudioOutputHooks

pub fn new_tracked_audio_output_hooks(AudioOutputHooks, Ref[AudioOutputStats]) -> AudioOutputHooks

pub fn reset_audio_output_hooks() -> Unit

pub fn samples_to_bytes(AudioFormat, Int) -> Int

pub fn samples_to_duration(AudioFormat, Int) -> Double

pub fn set_audio_output_hooks(AudioOutputHooks) -> Unit

// Errors

// Types and methods
pub struct AudioClip {
  format : AudioFormat
  data : Bytes
  loop_ : Bool
}
pub impl Show for AudioClip

pub struct AudioClipStream {
  clip : AudioClip
  mut position : Int
}
pub fn AudioClipStream::new(AudioClip) -> Self
pub fn AudioClipStream::remaining(Self) -> Int
pub fn AudioClipStream::reset(Self) -> Unit
pub impl AudioStream for AudioClipStream

pub struct AudioFormat {
  sample_rate : Int
  channels : Int
  bits_per_sample : Int
}
pub impl Show for AudioFormat

pub struct AudioOutputHooks {
  try_initialize : (AudioFormat) -> Bool
  write_frames : (FixedArray[Float], Int) -> Int
  suspend : () -> Unit
  resume_playback : () -> Unit
  close : () -> Unit
  output_latency : () -> Double
}

pub struct AudioOutputStats {
  initialized : Bool
  frames_written : Int
  suspended : Bool
}
pub impl Show for AudioOutputStats

pub struct BufferedAudioStream {
  chunks : Array[Bytes]
  mut total_bytes : Int
  mut read_chunk_idx : Int
  mut read_byte_idx : Int
  mut finalized : Bool
  mut final_length : Int
}
pub fn BufferedAudioStream::buffered_bytes(Self) -> Int
pub fn BufferedAudioStream::finalize(Self) -> Unit
pub fn BufferedAudioStream::has_data(Self) -> Bool
pub fn BufferedAudioStream::is_finalized(Self) -> Bool
pub fn BufferedAudioStream::new() -> Self
pub fn BufferedAudioStream::push_chunk(Self, Bytes) -> Unit
pub fn BufferedAudioStream::reset(Self) -> Unit
pub impl AudioStream for BufferedAudioStream

pub struct MixerAudioContext {
  mixer : @mizchi/audio.Mixer
  mut player_map : Array[(PlayerId, @mizchi/audio.VoiceId)]
  mut next_id : Int
  mut bgm_player_id : PlayerId?
  mut bgm_fade_target : Double
  mut bgm_fade_speed : Double
  mut bgm_current_volume : Double
  mut bgm_outgoing_id : PlayerId?
  mut bgm_outgoing_volume : Double
  mut bgm_outgoing_fade_speed : Double
}
pub fn MixerAudioContext::crossfade_bgm(Self, AudioClip, Double, volume? : Double) -> Unit
pub fn MixerAudioContext::dispose_outgoing_bgm(Self) -> Unit
pub fn MixerAudioContext::fade_bgm(Self, Double, Double) -> Unit
pub fn MixerAudioContext::new(Int) -> Self
pub fn MixerAudioContext::pause_bgm(Self) -> Unit
pub fn MixerAudioContext::play_bgm(Self, AudioClip, volume? : Double) -> Unit
pub fn MixerAudioContext::render(Self, Int, FixedArray[Float]) -> Unit
pub fn MixerAudioContext::resume_bgm(Self) -> Unit
pub fn MixerAudioContext::set_bgm_volume(Self, Double) -> Unit
pub fn MixerAudioContext::stop_bgm(Self) -> Unit
pub fn MixerAudioContext::tick_bgm(Self, Int) -> Unit
pub impl AudioContext for MixerAudioContext

pub struct PlayerId {
  value : Int
}
pub impl Show for PlayerId

pub enum PlayerState {
  Stopped
  Playing
  Paused
}
pub impl Show for PlayerState

pub struct SimpleAudioContext {
  mut players : Array[SimpleAudioPlayer]
  mut next_id : Int
  format : AudioFormat
}
pub fn SimpleAudioContext::new(AudioFormat) -> Self
pub fn SimpleAudioContext::player_count(Self) -> Int
pub fn SimpleAudioContext::tick(Self, Int) -> Unit
pub impl AudioContext for SimpleAudioContext

pub struct SimpleAudioPlayer {
  id : PlayerId
  clip : AudioClip
  mut state : PlayerState
  mut volume : Double
  mut position_samples : Int
}

// Type aliases

// Traits
pub trait AudioContext {
  create_player(Self, AudioClip) -> PlayerId raise
  play(Self, PlayerId) -> Unit raise
  pause(Self, PlayerId) -> Unit raise
  stop(Self, PlayerId) -> Unit raise
  state(Self, PlayerId) -> PlayerState
  set_volume(Self, PlayerId, Double) -> Unit
  current_position(Self, PlayerId) -> Double
  seek(Self, PlayerId, Double) -> Unit raise
  dispose(Self, PlayerId) -> Unit
}

pub trait AudioStream {
  read(Self, FixedArray[Byte], Int) -> Int
  content_length(Self) -> Int
}

