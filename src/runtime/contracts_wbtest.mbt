///|
fn install_test_web_hooks() -> Unit {
  @platform.set_web_canvas_hooks(
    @platform.new_web_canvas_hooks(
      fn(_canvas_selector, _options) { true },
      fn(_active) { () },
      fn() { false },
      fn(width, height) {
        @core.new_outside_size(width.to_double(), height.to_double())
      },
      fn(_canvas_selector, options) {
        @platform.create_webgpu_surface_token(
          77,
          options.width,
          options.height,
          1.0,
        )
      },
      fn(_active, _tick) { @core.empty_input_snapshot() },
      fn(_canvas_selector, _active, enabled) { enabled },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, mode) { mode },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, scale) { scale },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, enabled) { enabled },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active) { () },
      fn(_canvas_selector, _active) { () },
    ),
  )
  @gfx.set_web_graphics_hooks(
    @gfx.new_web_graphics_hooks(
      fn(_kind, _width, _height) { true },
      fn(_active, _kind, _pass) { () },
      fn(_active, _kind, _present) { () },
      fn(_active, _kind, _command) { () },
    ),
  )
}

///|
fn install_test_web_hooks_with_tick_input() -> Unit {
  @platform.set_web_canvas_hooks(
    @platform.new_web_canvas_hooks(
      fn(_canvas_selector, _options) { true },
      fn(_active) { () },
      fn() { false },
      fn(width, height) {
        @core.new_outside_size(width.to_double(), height.to_double())
      },
      fn(_canvas_selector, options) {
        @platform.create_webgpu_surface_token(
          77,
          options.width,
          options.height,
          1.0,
        )
      },
      fn(_active, tick) {
        @core.new_input_snapshot_full(0.0, 0.0, 0.0, 0.0, [tick], [], [], [])
      },
      fn(_canvas_selector, _active, enabled) { enabled },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, mode) { mode },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, scale) { scale },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active, enabled) { enabled },
      fn(_canvas_selector, _active, current) { current },
      fn(_canvas_selector, _active) { () },
      fn(_canvas_selector, _active) { () },
    ),
  )
  @gfx.set_web_graphics_hooks(
    @gfx.new_web_graphics_hooks(
      fn(_kind, _width, _height) { true },
      fn(_active, _kind, _pass) { () },
      fn(_active, _kind, _present) { () },
      fn(_active, _kind, _command) { () },
    ),
  )
}

///|
fn reset_test_web_hooks() -> Unit {
  @gfx.reset_web_graphics_hooks()
  @platform.reset_web_canvas_hooks()
}

///|
fn install_test_native_hooks() -> Unit {
  @platform.set_desktop_native_hooks(
    @platform.new_desktop_native_hooks(
      fn(_options) { true },
      fn(_active) { () },
      fn() { false },
      fn(width, height) {
        @core.new_outside_size(width.to_double(), height.to_double())
      },
      fn(_active, _tick) { @core.empty_input_snapshot() },
      fn(_active, enabled) { enabled },
      fn(_active, current) { current },
      fn(_active, mode) { mode },
      fn(_active, current) { current },
      fn(_active, scale) { scale },
      fn(_active, current) { current },
      fn(_active, enabled) { enabled },
      fn(_active, current) { current },
      fn(_active) { () },
      fn(_active) { () },
    ),
  )
  @gfx.set_native_graphics_hooks(
    @gfx.new_native_graphics_hooks(
      fn(_width, _height) { true },
      fn(_active, _pass) { () },
      fn(_active, _present) { () },
      fn(_active, _command) { () },
    ),
  )
}

///|
fn install_test_native_hooks_with_tick_input() -> Unit {
  @platform.set_desktop_native_hooks(
    @platform.new_desktop_native_hooks(
      fn(_options) { true },
      fn(_active) { () },
      fn() { false },
      fn(width, height) {
        @core.new_outside_size(width.to_double(), height.to_double())
      },
      fn(_active, tick) {
        @core.new_input_snapshot_full(0.0, 0.0, 0.0, 0.0, [tick], [], [], [])
      },
      fn(_active, enabled) { enabled },
      fn(_active, current) { current },
      fn(_active, mode) { mode },
      fn(_active, current) { current },
      fn(_active, scale) { scale },
      fn(_active, current) { current },
      fn(_active, enabled) { enabled },
      fn(_active, current) { current },
      fn(_active) { () },
      fn(_active) { () },
    ),
  )
  @gfx.set_native_graphics_hooks(
    @gfx.new_native_graphics_hooks(
      fn(_width, _height) { true },
      fn(_active, _pass) { () },
      fn(_active, _present) { () },
      fn(_active, _command) { () },
    ),
  )
}

///|
fn reset_test_native_hooks() -> Unit {
  @gfx.reset_native_graphics_hooks()
  @platform.reset_desktop_native_hooks()
}

///|
fn run_counting_game_with_webgpu() -> (Int, Int) raise {
  install_test_web_hooks()
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgpu_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop(game, platform, graphics, options, runtime_config)
  let result = (graphics.begin_count, graphics.end_count)
  reset_test_web_hooks()
  result
}

///|
fn run_counting_game_with_webgl() -> (Int, Int) raise {
  install_test_web_hooks()
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgl_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop(game, platform, graphics, options, runtime_config)
  let result = (graphics.begin_count, graphics.end_count)
  reset_test_web_hooks()
  result
}

///|
fn run_counting_game_with_native() -> (Int, Int) raise {
  install_test_native_hooks()
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_desktop_glfw_platform()
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_wgpu_native_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop(game, platform, graphics, options, runtime_config)
  let result = (graphics.begin_count, graphics.end_count)
  reset_test_native_hooks()
  result
}

///|
fn run_observed_input_ticks_with_webgpu() -> Array[Int] raise {
  install_test_web_hooks_with_tick_input()
  let observed_ticks : Ref[Array[Int]] = Ref::new([])
  let hooks = new_runtime_hooks(fn(tick, _input) {
    observed_ticks.val.push(tick)
  })
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgpu_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop_with_hooks(game, platform, graphics, options, runtime_config, hooks)
  let result = observed_ticks.val
  reset_test_web_hooks()
  result
}

///|
fn run_observed_input_ticks_with_native() -> Array[Int] raise {
  install_test_native_hooks_with_tick_input()
  let observed_ticks : Ref[Array[Int]] = Ref::new([])
  let hooks = new_runtime_hooks(fn(tick, _input) {
    observed_ticks.val.push(tick)
  })
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_desktop_glfw_platform()
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_wgpu_native_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop_with_hooks(game, platform, graphics, options, runtime_config, hooks)
  let result = observed_ticks.val
  reset_test_native_hooks()
  result
}

///|
test "plan_frame clamps updates by max_skip_frames" {
  let state = @core.initial_fixed_step_state()
  let cfg = @core.new_fixed_step_config(60, 8)
  let step = @core.step_fixed_timestep(state, 1000.0, cfg)
  let plan = plan_frame(step, 2)
  assert_eq(plan.updates, 2)
}

///|
test "run_loop works with noop game + stub platform/gfx" {
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgpu_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop(game, platform, graphics, options, runtime_config)
  assert_true(!platform.is_vsync_enabled())
}

///|
test "run_loop begin/end counts match between webgpu and webgl" {
  let (webgpu_begin, webgpu_end) = run_counting_game_with_webgpu()
  let (webgl_begin, webgl_end) = run_counting_game_with_webgl()

  assert_eq(webgpu_begin, webgl_begin)
  assert_eq(webgpu_end, webgl_end)
}

///|
test "run_loop begin/end counts match between native and webgpu" {
  let (native_begin, native_end) = run_counting_game_with_native()
  let (webgpu_begin, webgpu_end) = run_counting_game_with_webgpu()

  assert_eq(native_begin, webgpu_begin)
  assert_eq(native_end, webgpu_end)
}

///|
test "run_loop_with_hooks observed input ticks match between native and webgpu" {
  let native_ticks = run_observed_input_ticks_with_native()
  let web_ticks = run_observed_input_ticks_with_webgpu()
  assert_eq(native_ticks.length(), web_ticks.length())
  for i in 0..<native_ticks.length() {
    assert_eq(native_ticks[i], web_ticks[i])
  }
}

///|
test "run_loop_with_hooks passes captured input snapshots to observer" {
  install_test_web_hooks_with_tick_input()
  let observed_ticks : Ref[Array[Int]] = Ref::new([])
  let observed_first_keys : Ref[Array[Int]] = Ref::new([])
  let hooks = new_runtime_hooks(fn(tick, input) {
    observed_ticks.val.push(tick)
    if input.pressed_keys.length() > 0 {
      observed_first_keys.val.push(input.pressed_keys[0])
    } else {
      observed_first_keys.val.push(-1)
    }
  })
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgpu_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop_with_hooks(game, platform, graphics, options, runtime_config, hooks)
  assert_true(observed_ticks.val.length() > 0)
  assert_eq(observed_ticks.val.length(), observed_first_keys.val.length())
  for i in 0..<observed_ticks.val.length() {
    assert_eq(observed_ticks.val[i], observed_first_keys.val[i])
    if i > 0 {
      assert_true(observed_ticks.val[i] > observed_ticks.val[i - 1])
    }
  }
  reset_test_web_hooks()
}

///|
test "input edge observer tracks deltas and keeps bounded history" {
  let observer = new_input_edge_observer_state(2)
  let edge1 = observe_input_edge(
    observer,
    1,
    @core.new_input_snapshot_full(
      0.0,
      0.0,
      0.0,
      0.0,
      [1],
      [0],
      [@core.new_touch_point(10, 1.0, 2.0)],
      [@core.new_gamepad_snapshot(7, [], [1])],
    ),
  )
  assert_eq(edge1.tick, 1)
  assert_eq(edge1.just_pressed_key_count, 1)
  assert_eq(edge1.just_released_key_count, 0)
  assert_eq(edge1.just_pressed_mouse_button_count, 1)
  assert_eq(edge1.just_released_mouse_button_count, 0)
  assert_eq(edge1.just_pressed_touch_count, 1)
  assert_eq(edge1.just_released_touch_count, 0)
  assert_eq(edge1.just_connected_gamepad_count, 1)
  assert_eq(edge1.just_disconnected_gamepad_count, 0)
  assert_eq(edge1.just_pressed_gamepad_button_count, 1)
  assert_eq(edge1.just_released_gamepad_button_count, 0)

  let edge2 = observe_input_edge(
    observer,
    2,
    @core.new_input_snapshot_full(
      0.0,
      0.0,
      0.0,
      0.0,
      [],
      [0, 2],
      [@core.new_touch_point(11, 3.0, 4.0)],
      [
        @core.new_gamepad_snapshot(7, [], [3]),
        @core.new_gamepad_snapshot(8, [], []),
      ],
    ),
  )
  assert_eq(edge2.just_pressed_key_count, 0)
  assert_eq(edge2.just_released_key_count, 1)
  assert_eq(edge2.just_pressed_mouse_button_count, 1)
  assert_eq(edge2.just_released_mouse_button_count, 0)
  assert_eq(edge2.just_pressed_touch_count, 1)
  assert_eq(edge2.just_released_touch_count, 1)
  assert_eq(edge2.just_connected_gamepad_count, 1)
  assert_eq(edge2.just_disconnected_gamepad_count, 0)
  assert_eq(edge2.just_pressed_gamepad_button_count, 1)
  assert_eq(edge2.just_released_gamepad_button_count, 1)

  let edge3 = observe_input_edge(
    observer,
    3,
    @core.new_input_snapshot_full(0.0, 0.0, 0.0, 0.0, [], [], [], []),
  )
  assert_eq(edge3.just_pressed_key_count, 0)
  assert_eq(edge3.just_released_key_count, 0)
  assert_eq(edge3.just_pressed_mouse_button_count, 0)
  assert_eq(edge3.just_released_mouse_button_count, 2)
  assert_eq(edge3.just_pressed_touch_count, 0)
  assert_eq(edge3.just_released_touch_count, 1)
  assert_eq(edge3.just_connected_gamepad_count, 0)
  assert_eq(edge3.just_disconnected_gamepad_count, 2)
  assert_eq(edge3.just_pressed_gamepad_button_count, 0)
  assert_eq(edge3.just_released_gamepad_button_count, 1)

  let history = append_input_edge_history(observer, [])
  assert_eq(history.length(), 2)
  assert_eq(history[0].tick, 2)
  assert_eq(history[1].tick, 3)
}

///|
test "new_input_edge_runtime_hooks wires observer to run_loop_with_hooks" {
  install_test_web_hooks_with_tick_input()
  let observer = new_input_edge_observer_state(4)
  let hooks = new_input_edge_runtime_hooks(observer)
  let game = @core.new_noop_game(320, 240)
  let platform = @platform.create_web_canvas_platform("#app")
  let surface = platform.current_surface()
  let gfx_options = @gfx.default_graphics_backend_options()
  let graphics = @gfx.create_webgpu_graphics(surface, gfx_options)
  let options = @core.default_run_options()
  let runtime_config = {
    max_skip_frames: 2,
    enable_vsync: false,
    clear_screen_every_frame: true,
  }
  run_loop_with_hooks(game, platform, graphics, options, runtime_config, hooks)
  let history = append_input_edge_history(observer, [])
  assert_true(history.length() > 0)
  assert_true(history[history.length() - 1].tick > 0)
  reset_test_web_hooks()
}
