// Generated using `moon info`, DON'T EDIT IT
package "mizchi/game_engine/ai"

import {
  "mizchi/game_engine/core",
}

// Values
pub fn[P : AIPolicy, S : SensorBridge, A : ActuatorBridge, C : AIScheduler] create_ai_post_update_hook(P, S, A, C, AIRuntimeState) -> (Int, @core.FrameBudget) -> Unit

pub fn default_ai_budget() -> AIBudget

pub fn default_ai_runtime_config() -> AIRuntimeConfig

pub fn[P : AIPolicy, S : SensorBridge, A : ActuatorBridge, C : AIScheduler] run_ai_tick(P, S, A, C, @core.FrameBudget, Int, BlackboardSnapshot) -> BlackboardSnapshot raise

// Errors

// Types and methods
pub struct AIBudget {
  max_decision_ms : Int
  max_nodes : Int
  max_model_tokens : Int
}
pub impl Show for AIBudget

pub struct AIRuntimeConfig {
  mut enabled : Bool
  mut global_budget : AIBudget?
  mut base_seed : Int
  mut trace_enabled : Bool
  max_trace_history : Int
}
pub impl Show for AIRuntimeConfig

pub struct AIRuntimeState {
  mut blackboard : BlackboardSnapshot
  mut traces : Array[Array[DecisionTrace]]
  mut tick_traces : Map[Int, Array[DecisionTrace]]
  mut total_decisions : Int
  mut total_ticks : Int
  mut last_tick_decision_count : Int
  config : AIRuntimeConfig
}
pub fn AIRuntimeState::clear_budget_override(Self) -> Unit
pub fn AIRuntimeState::clear_traces(Self) -> Unit
pub fn AIRuntimeState::current_blackboard(Self) -> BlackboardSnapshot
pub fn AIRuntimeState::get_config(Self) -> AIRuntimeConfig
pub fn AIRuntimeState::get_recent_trace_ticks(Self, Int) -> Array[Int]
pub fn AIRuntimeState::get_traces_for_tick(Self, Int) -> Array[DecisionTrace]
pub fn AIRuntimeState::last_tick_decision_count(Self) -> Int
pub fn AIRuntimeState::new() -> Self
pub fn AIRuntimeState::new_with_blackboard(BlackboardSnapshot) -> Self
pub fn AIRuntimeState::new_with_config(AIRuntimeConfig) -> Self
pub fn AIRuntimeState::set_budget(Self, AIBudget) -> Unit
pub fn AIRuntimeState::set_enabled(Self, Bool) -> Unit
pub fn AIRuntimeState::set_seed(Self, Int) -> Unit
pub fn AIRuntimeState::set_trace_enabled(Self, Bool) -> Unit
pub fn AIRuntimeState::total_decisions(Self) -> Int
pub fn AIRuntimeState::total_ticks(Self) -> Int
pub fn AIRuntimeState::trace_count(Self) -> Int

pub enum ActionIntent {
  Idle
  Move(Double, Double)
  Aim(Double, Double)
  Trigger(String)
  EmitEvent(String)
}
pub impl Show for ActionIntent

pub struct AgentId {
  value : Int
}
pub impl Show for AgentId

pub struct BlackboardEntry {
  key : String
  value : String
}
pub impl Show for BlackboardEntry

pub struct BlackboardSnapshot {
  entries : Array[BlackboardEntry]
}
pub impl Show for BlackboardSnapshot

pub struct DecisionContext {
  tick : Int
  frame : @core.FrameBudget
  deterministic_seed : Int
  budget : AIBudget
  perception : SensorSnapshot
  blackboard : BlackboardSnapshot
}
pub impl Show for DecisionContext

pub struct DecisionResult {
  actions : Array[ActionIntent]
  next_blackboard : BlackboardSnapshot
  trace : Array[DecisionTrace]
}
pub impl Show for DecisionResult

pub struct DecisionTrace {
  stage : String
  score : Double
  note : String
}
pub impl Show for DecisionTrace

pub struct SensorSnapshot {
  self_x : Double
  self_y : Double
  health : Double
  visible_entities : Array[Int]
  tags : Array[String]
}
pub impl Show for SensorSnapshot

// Type aliases

// Traits
pub trait AIPolicy {
  decide(Self, DecisionContext) -> DecisionResult raise
}

pub trait AIScheduler {
  select_agents(Self, Int) -> Array[AgentId]
  budget_for(Self, AgentId) -> AIBudget
}

pub trait ActuatorBridge {
  apply(Self, AgentId, Array[ActionIntent]) -> Unit raise
}

pub trait SensorBridge {
  capture(Self, AgentId, Int) -> SensorSnapshot
}

